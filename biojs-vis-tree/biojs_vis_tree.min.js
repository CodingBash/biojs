(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
if (typeof biojs === 'undefined') {
  module.exports = biojs = {}
}
if (typeof biojs.vis === 'undefined') {
  module.exports = biojs.vis = {}
}
biojs.vis.tree = require('./lib/index')

},{"./lib/index":3}],2:[function(require,module,exports){
var diagonal = function () {

    var d = function (diagonalPath) {
	var source = diagonalPath.source;
        var target = diagonalPath.target;
        var midpointX = (source.x + target.x) / 2;
        var midpointY = (source.y + target.y) / 2;
        var pathData = [source, {x: target.x, y: source.y}, target];
	pathData = pathData.map(d.projection());
	return d.path()(pathData, radial_calc.call(this,pathData))
    };

    var api = tnt.utils.api (d)
	.getset ('projection')
	.getset ('path')
    
    var coordinateToAngle = function (coord, radius) {
      	var wholeAngle = 2 * Math.PI,
        quarterAngle = wholeAngle / 4
	
      	var coordQuad = coord[0] >= 0 ? (coord[1] >= 0 ? 1 : 2) : (coord[1] >= 0 ? 4 : 3),
        coordBaseAngle = Math.abs(Math.asin(coord[1] / radius))
	
      	// Since this is just based on the angle of the right triangle formed
      	// by the coordinate and the origin, each quad will have different 
      	// offsets
      	var coordAngle;
      	switch (coordQuad) {
      	case 1:
      	    coordAngle = quarterAngle - coordBaseAngle
      	    break
      	case 2:
      	    coordAngle = quarterAngle + coordBaseAngle
      	    break
      	case 3:
      	    coordAngle = 2*quarterAngle + quarterAngle - coordBaseAngle
      	    break
      	case 4:
      	    coordAngle = 3*quarterAngle + coordBaseAngle
      	}
      	return coordAngle
    };

    var radial_calc = function (pathData) {
	var src = pathData[0];
	var mid = pathData[1];
	var dst = pathData[2];
	var radius = Math.sqrt(src[0]*src[0] + src[1]*src[1]);
	var srcAngle = coordinateToAngle(src, radius);
	var midAngle = coordinateToAngle(mid, radius);
	var clockwise = Math.abs(midAngle - srcAngle) > Math.PI ? midAngle <= srcAngle : midAngle > srcAngle;
	var rotation = 0;
	var largeArc = 0;
	var sweep;
	var curr_sweep = d3.select(this).attr("__sweep");
	if (curr_sweep === null) {
	    sweep = (clockwise ? 0 : 1);
	    d3.select(this).attr("__sweep", sweep);
	} else {
	    sweep = curr_sweep;
	}
	return {
	    rotation : rotation,
	    largeArc : largeArc,
	    radius   : radius,
	    sweep    : sweep
	};
    };

    return d;
};

// vertical diagonal for rect branches
diagonal.vertical = function () {
    var projection = function(d) { 
	return [d.y, d.x];
    }

    var path = function(pathData, obj) {
	var src = pathData[0];
	var mid = pathData[1];
	var dst = pathData[2];

	return "M" + src + ' ' +
	    "A" + src + ' 0 0,' + obj.sweep + ' ' + src +
	    "L" + mid + ' ' +
	    "L" + dst;
    };

    return diagonal()
      	.path(path)
      	.projection(projection);
};

diagonal.radial = function () {
    var path = function(pathData, obj) {
      	var src = pathData[0];
      	var mid = pathData[1];
      	var dst = pathData[2];
	var radius = obj.radius;
	var rotation = obj.rotation;
	var largeArc = obj.largeArc;
	var sweep = obj.sweep;

      	return 'M' + src + ' ' + "A" + [radius,radius] + ' ' + rotation + ' ' + largeArc+','+sweep + ' ' + mid + 'L' + dst + 'L' + dst;
    };

    var projection = function(d) {
      	var r = d.y, a = (d.x - 90) / 180 * Math.PI;
      	return [r * Math.cos(a), r * Math.sin(a)];
    };

    return diagonal()
      	.path(path)
      	.projection(projection)
};

module.exports = diagonal;

},{}],3:[function(require,module,exports){
module.exports.tree = require("./tree");
//module.exports.diagonal = require("diagonal");
//module.exports.node = require("node");





},{"./tree":7}],4:[function(require,module,exports){
var export_label = function () {
"use strict";

    // TODO: Not sure if we should be removing by default prev labels
    // or it would be better to have a separate remove method called by the vis
    // on update
    // We also have the problem that we may be transitioning from
    // text to img labels and we need to remove the label of a different type
    var label = function (node) {
	if (typeof (node) !== 'function') {
            throw(node);
        }

	label.display().call(this, node)
	    .attr("class", "label")
	    .attr("transform", "translate (" + label.transform()()[0] + " " + label.transform()()[1] + ")")
	    .on("click", function(){
		if (label.on_click() !== undefined) {
		    d3.event.stopPropagation();
		    label.on_click().call(this, node);
		}
	    });

    };

    //var api = tnt.utils.api (label)
	label.width = function () { throw "Need a width callback" };
	label.height = function () { throw "Need a height callback" };
	label.display = function () { throw "Need a display callback" };
	label.transform = function () { return [10, 5] };
	label.on_click;

    label.remove = function () {
	d3.select(this)
	    .selectAll(".label")
	    .remove();
    };

    return label;
};

// Text based labels
export_label.text = function () {
    var label = export_label();

    label.fontsize = 10;
    label.color = "#000";
    label.text = function (d) {
    	    return d.data().name;
    };

    label.display = function (node) {
	var l = d3.select(this);
	console.log("---");
	console.log(l);
	l = l.append("text");
	l = l.text(function(){
			console.log("hi");
		return label.text()(node)
	    });
	l = l.style('font-size', label.fontsize() + "px");
	l = l.style('fill', d3.functor(label.color())(node));

	return l;
    };

    label.width = function (node) {
	var svg = d3.select("body")
	    .append("svg")
	    .attr("height", 0)
	    .style('visibility', 'hidden');

	var text = svg
	    .append("text")
	    .style('font-size', label.fontsize() + "px")
	    .text(label.text()(node));

	var width = text.node().getBBox().width;
	svg.remove();

	return width;
    };

    label.height = function (node) {
	return label.fontsize();
    };

    return label;
};

// Image based labels
export_label.img = function () {
    var label = export_label();

    //var api = tnt.utils.api (label)
    //	.getset ('src', function () {})

    label.display = function (node) {
	if (label.src()(node)) {
	    var l = d3.select(this)
		.append("image")
		.attr("width", label.width()())
		.attr("height", label.height()())
		.attr("xlink:href", label.src()(node));
	    return l;
	}
	// TODO:
	return d3.select(this)
	    .append("text");
    };

    label.transform = function () {
	return ([10, -(label.height()() / 2)]);
    };

    return label;
};

// Labels made of 2+ simple labels
export_label.composite = function () {

    var labels = [];

    var label = function (node) {
	for (var i=0; i<labels.length; i++) {
	    labels[i].call(this, node);
	}
    };

    //var api = tnt.utils.api (label)

    label.add_label = function (display) {
	var curr_labels = [];
	for (var i=0; i<labels.length; i++) {
	    curr_labels.push(labels[i]);
	}

	display._super_ = {};
	tnt.utils.api (display._super_)
	    .get ('transform', display.transform());

	display.transform( function (node) {
	    var curr_offset = 0;
	    for (var i=0; i<curr_labels.length; i++) {
		curr_offset += curr_labels[i].width()(node);
		curr_offset += curr_labels[i].transform()(node)[0];
	    }
	    return ([curr_offset + display._super_.transform()(node)[0], display._super_.transform()(node)[1]]);
	});

	labels.push(display);
	return label;
    };

    label.width = function () {
	return function (node) {
	    var tot_width = 0;
	    for (var i=0; i<labels.length; i++) {
		tot_width += parseInt(labels[i].width()(node));
		tot_width += parseInt(labels[i]._super_.transform()(node)[0]);
	    }

	    return tot_width;
	}
    };

    label.height = function () {
	return function (node) {
	    var max_height = 0;
	    for (var i=0; i<labels.length; i++) {
		var curr_height = labels[i].height()(node);
		if ( curr_height > max_height) {
		    max_height = curr_height;
		}
	    }
	    return max_height;
	}
    };

    label.remove = function (node) {
	for (var i=0; i<labels.length; i++) {
	    labels[i].remove.call(this, node);
	}
    };

    return label;
};

module.exports = export_label;

},{}],5:[function(require,module,exports){
// Based on the code by Ken-ichi Ueda in http://bl.ocks.org/kueda/1036776#d3.phylogram.js
var diagonal = require("./diagonal");

var elayout = function () {

    var l = function () {
    };

    var cluster = d3.layout.cluster()
	.sort(null)
	.value(function (d) {return d.length} )
	// .children(function (d) {return d.branchset})
	.separation(function () {return 1});

    //var api = tnt.utils.api (l)
	l.scale = true;
	l.max_leaf_label_width = 0;
	l.cluster = cluster;
	l.yscale = function () {throw "yscale is not defined in the base object"};
	l.adjust_cluster_size = function () {throw "adjust_cluster_size is not defined in the base object" };
	l.width = function () {throw "width is not defined in the base object"};
	l.height = function () {throw "height is not defined in the base object"};

    l.scale_branch_lengths = function (curr) {
	if (l.scale() === false) {
	    return
	}

	var nodes = curr.nodes;
	var tree = curr.tree;

	var root_dists = nodes.map (function (d) {
	    return d._root_dist;
	});

	var yscale = l.yscale(root_dists);
	tree.apply (function (node) {
	    node.property("y", yscale(node.root_dist()));
	});
    };

    return l;
};

elayout.vertical = function () {
    var layout = elayout();

    //var api = tnt.utils.api (layout)
	layout.width = 360;
	layout.translate_vis = [20,20];
	layout.diagonal = diagonal.vertical;
	layout.transform_node = function (d) {
    	    return "translate(" + d.y + "," + d.x + ")";
	};

    layout.height = function (params) {
    	return (params.n_leaves * params.label_height);
    }; 

    layout.yscale = function (dists) {
    	return d3.scale.linear()
    	    .domain([0, d3.max(dists)])
    	    .range([0, layout.width() - 20 - layout.max_leaf_label_width()]);
    };

    layout.adjust_cluster_size = function (params) {
    	var h = layout.height(params);
    	var w = layout.width() - layout.max_leaf_label_width() - layout.translate_vis()[0] - params.label_padding;
    	layout.cluster.size ([h,w]);
    	return layout;
    };

    return layout;
};

elayout.radial = function () {
    var layout = elayout();
    var default_width = 360;
    var r = default_width / 2;

    var conf = {
    	width : 360
    };

    //var api = tnt.utils.api (layout)
	layout.width = 360;
	layout.translate_vis = [r, r*1.3]; // TODO: 1.3 should be replaced by a sensible value
	layout.transform_node = function (d) {
	    return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")";
	};
	layout.diagonal = diagonal.radial;
	layout.height = function () { return conf.width };

    // Changes in width affect changes in r
    layout.width.transform (function (val) {
    	r = val / 2;
    	layout.cluster.size([360, r-120])
    	layout.translate_vis([r, r*1.3]);
    	return val;
    });

    layout.yscale = function (dists) {
	return d3.scale.linear()
	    .domain([0,d3.max(dists)])
	    .range([0, r]);
    };

    layout.adjust_cluster_size = function (params) {
	return;
    };

    return layout;
};

module.exports = elayout;

},{"./diagonal":2}],6:[function(require,module,exports){
var export_node = function (data) {
    "use strict";

    var node = function () {
    };

    //var api = tnt.utils.api (node);

    // API
//     node.nodes = function() {
// 	if (cluster === undefined) {
// 	    cluster = d3.layout.cluster()
// 	    // TODO: length and children should be exposed in the API
// 	    // i.e. the user should be able to change this defaults via the API
// 	    // children is the defaults for parse_newick, but maybe we should change that
// 	    // or at least not assume this is always the case for the data provided
// 		.value(function(d) {return d.length})
// 		.children(function(d) {return d.children});
// 	}
// 	nodes = cluster.nodes(data);
// 	return nodes;
//     };

    var apply_to_data = function (data, cbak) {
	cbak(data);
	if (data.children !== undefined) {
	    for (var i=0; i<data.children.length; i++) {
		apply_to_data(data.children[i], cbak);
	    }
	}
    };
	
	//iterator copied from tnt.utils.iterator 	
    var iterator = function (init_val) {
		var i = init_val;
		var iter = function () {
			return i++;
		};	
		return iter;
	}
	
    var create_ids = function () {
	var i = iterator(1);
	// We can't use apply because apply creates new trees on every node
	// We should use the direct data instead
	apply_to_data (data, function (d) {
	    if (d._id === undefined) {
		d._id = i();
		// TODO: Not sure _inSubTree is strictly necessary
		// d._inSubTree = {prev:true, curr:true};
	    }
	});
    };

    var link_parents = function (data) {
	if (data === undefined) {
	    return;
	}
	if (data.children === undefined) {
	    return;
	}
	for (var i=0; i<data.children.length; i++) {
	    // _parent?
	    data.children[i]._parent = data;
	    link_parents(data.children[i]);
	}
    };

    var compute_root_dists = function (data) {
	apply_to_data (data, function (d) {
	    var l;
	    if (d._parent === undefined) {
		d._root_dist = 0;
	    } else {
		var l = 0;
		if (d.branch_length) {
		    l = d.branch_length
		}
		d._root_dist = l + d._parent._root_dist;
	    }
	});
    };

    // TODO: data can't be rewritten used the api yet. We need finalizers
    node.data = function(new_data) {
	if (!arguments.length) {
	    return data
	}
	data = new_data;
	create_ids();
	link_parents(data);
	compute_root_dists(data);
	return node;
    };
	
    // We bind the data that has been passed
    node.data(data);

    node.find_node_by_field = function(value, field) {
	
	


	if (typeof (field) === 'function') {
	    if (field (data) === value) {
		return node;
	    }
	} else {
	    if (data[field] === value) {
		return node;
	    }
	}
	if (data._children !== undefined) {
	    for (var j=0; j<data._children.length; j++) {
		var c = export_node(data._children[j]);
		var f = c.find_node_by_field(value, field);
		if (f !== undefined) {
		    return f;
		}
	    }
	}

	if (data.children !== undefined) {
	    for (var i=0; i<data.children.length; i++) {
		
	
		var n = export_node(data.children[i]);
		
		var found = n.find_node_by_field(value, field);
		if (found !== undefined) {
		    return found;
		}
	    }
	}
    };

    node.find_node_by_name = function(name) {
	return node.find_node_by_field(name, 'name');
    };

    node.toggle = function() {
	if (data) {
	    if (data.children) { // Uncollapsed -> collapse
		var hidden = 0;
		node.apply (function (n) {
		    var hidden_here = n.n_hidden() || 0;
		    hidden += (n.n_hidden() || 0) + 1;
		});
		node.n_hidden (hidden-1);
		data._children = data.children;
		data.children = undefined;
	    } else {             // Collapsed -> uncollapse
		node.n_hidden(0);
		data.children = data._children;
		data._children = undefined;
	    }
	}
    };

    node.is_collapsed = function () {
	return (data._children !== undefined && data.children === undefined);
    };

    var has_ancestor = function(n, ancestor) {
	// It is better to work at the data level
	n = n.data();
	ancestor = ancestor.data();
	if (n._parent === undefined) {
	    return false
	}
	n = n._parent
	for (;;) {
	    if (n === undefined) {
		return false;
	    }
	    if (n === ancestor) {
		return true;
	    }
	    n = n._parent;
	}
    };

    // This is the easiest way to calculate the LCA I can think of. But it is very inefficient too.
    // It is working fine by now, but in case it needs to be more performant we can implement the LCA
    // algorithm explained here:
    // http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=lowestCommonAncestor
    node.lca = function (nodes) {
	if (nodes.length === 1) {
	    return nodes[0];
	}
	var lca_node = nodes[0];
	for (var i = 1; i<nodes.length; i++) {
	    lca_node = _lca(lca_node, nodes[i]);
	}
	return lca_node;
	// return export_node(lca_node);
    };

    var _lca = function(node1, node2) {
	if (node1.data() === node2.data()) {
	    return node1;
	}
	if (has_ancestor(node1, node2)) {
	    return node2;
	}
	return _lca(node1, node2.parent());
    };

    node.n_hidden = function (val) {
	if (!arguments.length) {
	    return node.property('_hidden');
	}
	node.property('_hidden', val);
	return node
    };

    node.get_all_nodes = function () {
	var nodes = [];
	node.apply(function (n) {
	    nodes.push(n);
	});
	return nodes;
    };

    node.get_all_leaves = function () {
	var leaves = [];
	node.apply(function (n) {
	    if (n.is_leaf()) {
		leaves.push(n);
	    }
	});
	return leaves;
    };

    node.get_all_descendents = function () {
	var leaves = [];
	node.apply(function (n) {
	    // if (n.is_leaf()) {
		leaves.push(n);
	    // }
	});
	return leaves;
    };

    node.upstream = function(cbak) {
	cbak(node);
	var parent = node.parent();
	if (parent !== undefined) {
	    parent.upstream(cbak);
	}
//	export_node(parent).upstream(cbak);
// 	node.upstream(node._parent, cbak);
    };

    node.subtree = function(nodes) {
    	var node_counts = {};
    	for (var i=0; i<nodes.length; i++) {
	    var n = nodes[i];
	    if (n !== undefined) {
		n.upstream (function (this_node){
		    var id = this_node.id();
		    if (node_counts[id] === undefined) {
			node_counts[id] = 0;
		    }
		    node_counts[id]++
    		});
	    }
    	}
    

	var is_singleton = function (node_data) {
	    var n_children = 0;
	    if (node_data.children === undefined) {
		return false;
	    }
	    for (var i=0; i<node_data.children.length; i++) {
		var id = node_data.children[i]._id;
		if (node_counts[id] > 0) {
		    n_children++;
		}
	    }
	    return n_children === 1;
	};

	var copy_data = function (orig_data, subtree, condition) {
            if (orig_data === undefined) {
		return;
            }

            if (condition(orig_data)) {
		var copy = copy_node(orig_data);
		if (subtree.children === undefined) {
                    subtree.children = [];
		}
		subtree.children.push(copy);
		if (orig_data.children === undefined) {
                    return;
		}
		for (var i = 0; i < orig_data.children.length; i++) {
                    copy_data (orig_data.children[i], copy, condition);
		}
            } else {
		if (orig_data.children === undefined) {
                    return;
		}
		for (var i = 0; i < orig_data.children.length; i++) {
                    copy_data(orig_data.children[i], subtree, condition);
		}
            }
	};

	var copy_node = function (node_data) {
	    var copy = {};
	    // copy all the own properties excepts links to other nodes or depth
	    for (var param in node_data) {
		if ((param === "children") ||
		    (param === "children") ||
		    (param === "_parent") ||
		    (param === "depth")) {
		    continue;
		}
		if (node_data.hasOwnProperty(param)) {
		    copy[param] = node_data[param];
		}
	    }
	    return copy;
	};

	var subtree = {};
	copy_data (data, subtree, function (node_data) {
	    var node_id = node_data._id;
	    var counts = node_counts[node_id];

	    if (counts === undefined) {
	    	return false;
	    }
// 	    if ((node.children !== undefined) && (node.children.length < 2)) {
// 		return false;
// 	    }
	    if ((counts > 1) && (!is_singleton(node_data))) {
		return true;
	    }
	    if ((counts > 0) && (node_data.children === undefined)) {
		return true;
	    }
	    return false;
	});

	return export_node(subtree.children[0]);
    };

    // TODO: This method visits all the nodes
    // a more performant version should return true
    // the first time cbak(node) is true
    node.present = function (cbak) {
	// cbak should return true/false
	var is_true = false;
	node.apply (function (n) {
	    if (cbak(n) === true) {
		is_true = true;
	    }
	});
	return is_true;
    };

    // cbak is called with two nodes
    // and should return -1,0,1
    node.sort = function (cbak) {
	if (data.children === undefined) {
	    return;
	}

	var new_children = [];
	for (var i=0; i<data.children.length; i++) {
	    new_children.push(export_node(data.children[i]));
	}

	new_children.sort(cbak);
	data.children = [];
	for (var i=0; i<new_children.length; i++) {
	    data.children.push(new_children[i].data());
	}

	for (var i=0; i<data.children.length; i++) {
	    export_node(data.children[i]).sort(cbak);
	}
    };

    node.apply = function(cbak) {
	cbak(node);
	if (data.children !== undefined) {
	    for (var i=0; i<data.children.length; i++) {
		var n = export_node(data.children[i])
		n.apply(cbak);
	    }
	}
    };

    // TODO: Not sure if it makes sense to set via a callback:
    // root.property (function (node, val) {
    //    node.deeper.field = val
    // }, 'new_value')
    node.property = function(prop, value) {
	if (arguments.length === 1) {
	    if ((typeof prop) === 'function') {
		return prop(data)	
	    }
	    return data[prop]
	}
	if ((typeof prop) === 'function') {
	    prop(data, value);   
	}
	data[prop] = value;
	return node;
    };

    node.is_leaf = function() {
	return data.children === undefined;
    };

    // It looks like the cluster can't be used for anything useful here
    // It is now included as an optional parameter to the ) method call
    // so I'm commenting the getter
    // node.cluster = function() {
    // 	return cluster;
    // };

    // node.depth = function (node) {
    //     return node.depth;
    // };

//     node.name = function (node) {
//         return node.name;
//     };

    node.id = function () {
	return node.property('_id');
    };

    node.node_name = function () {
	return node.property('name');
    };

    node.branch_length = function () {
	return node.property('branch_length');
    };

    node.root_dist = function () {
	return node.property('_root_dist');
    };

    node.children = function () {
	if (data.children === undefined) {
	    return;
	}
	var children = [];
	for (var i=0; i<data.children.length; i++) {
	    children.push((data.children[i]));
	}
	return children;
    };

    node.parent = function () {
	if (data._parent === undefined) {
	    return undefined;
	}
	return export_node(data._parent);
    };

    return node;

};

module.exports = export_node;


},{}],7:[function(require,module,exports){
var label = require("./label");
var layout = require("./layout");
var tnode = require("./node");

var tree = function () {
 "use strict";

    var conf = {
	duration         : 500,      // Duration of the transitions
	label            : label.text(),
	layout           : layout.vertical(),
	on_click         : function () {},
	on_dbl_click     : function () {},
	on_mouseover    : function () {},
	link_color       : 'steelblue',
	node_color       : 'steelblue',
	node_circle_size : 4.5,
    };

    // Keep track of the focused node
    // TODO: Would it be better to have multiple focused nodes? (ie use an array)
    var focused_node;

    // Extra delay in the transitions (TODO: Needed?)
    var delay = 0;

    // Ease of the transitions
    var ease = "cubic-in-out";

    // If labels should be skipped
    // TODO: Replace this with a valid tree.label that does nothing
    // var skip_labels = false;

    // TODO: Don't know if this is useful or not
    // Probably this can go and see if this can be set with the API
    var curr_species = "Homo_sapiens";

    // By node data
    var sp_counts = {};
 
    var scale = false;

    // The id of the tree container
    var div_id;

    // The tree visualization (svg)
    var svg;
    var vis;

    // TODO: For now, counts are given only for leaves
    // but it may be good to allow counts for internal nodes
    var counts = {};

    // The full tree
    var base = {
	tree : undefined,
	data : undefined,	
	nodes : undefined,
	links : undefined
    };

    // The curr tree. Needed to re-compute the links / nodes positions of subtrees
    var curr = {
	tree : undefined,
	data : undefined,
	nodes : undefined,
	links : undefined
    };

    // The cbak returned
    var tree = function (div) {
	div_id = d3.select(div).attr("id");

        var tree_div = d3.select(div)
            .append("div")
	    .attr("class", "tnt_groupDiv");

	var cluster = conf.layout.cluster;

	var n_leaves = curr.tree.get_all_leaves().length;

	var max_leaf_label_length = function (tree) {
	    var max = 0;
	    var leaves = tree.get_all_leaves();
	    for (var i=0; i<leaves.length; i++) {
		var label_width = conf.label.width()(leaves[i]);
		if (label_width > max) {
		    max = label_width;
		}
	    }
	    return max;
	};


	var max_label_length = max_leaf_label_length(curr.tree);
	conf.layout.max_leaf_label_width(max_label_length);

	// Cluster size is the result of...
	// total width of the vis - transform for the tree - max_leaf_label_width - horizontal transform of the label
	// TODO: Substitute 15 by the horizontal transform of the nodes
	var cluster_size_params = {
	    n_leaves : n_leaves,
	    label_height : d3.functor(conf.label.height())(),
	    label_padding : 15
	};

	conf.layout.adjust_cluster_size(cluster_size_params);

	var diagonal = conf.layout.diagonal();
	var transform = conf.layout.transform_node;

	svg = tree_div
	    .append("svg")
	    .attr("width", conf.layout.width())
//	    .attr("height", (n_leaves * label.height()()) + 20)
	    .attr("height", conf.layout.height(cluster_size_params) + 30)
	    .attr("fill", "none");

	vis = svg
	    .append("g")
	    .attr("id", "tnt_st_" + div_id)
	    .attr("transform",
		  "translate(" +
		  conf.layout.translate_vis()[0] +
		  "," +
		  conf.layout.translate_vis()[1] +
		  ")");

	curr.nodes = cluster.nodes(curr.data);
	conf.layout.scale_branch_lengths(curr);
	curr.links = cluster.links(curr.nodes);

	// LINKS
	var link = vis.selectAll("path.tree_link")
	    .data(curr.links, function(d){return d.target._id});
	
	link
	    .enter()
	    .append("path")
	    .attr("class", "tree_link")
	    .attr("id", function(d) {
	    	return "tree_link_" + div_id + "_" + d.target._id;
	    })
	    .style("stroke", function (d) {
		return d3.functor(conf.link_color)(tnode(d.source), tnode(d.target));
	    })
	    .attr("d", diagonal);	    

	// NODES
	var node = vis.selectAll("g.tnode")
	    .data(curr.nodes, function(d) {return d._id});

	var new_node = node
	    .enter().append("g")
	    .attr("class", function(n) {
		if (n.children) {
		    if (n.depth == 0) {
			return "root tnode"
		    } else {
			return "inner tnode"
		    }
		} else {
		    return "leaf tnode"
		}
	    })
	    .attr("id", function(d) {
		return "tnode_" + div_id + "_" + d._id
	    })
	    .attr("transform", transform);

	new_node
	    .append('circle')
	    .attr("r", function (d) {
		return d3.functor(conf.node_circle_size)(tnode(d));
	    })	 
	    .attr('fill', function (d) {
		return d3.functor(conf.node_color)(tnode(d));
	    })
	    .attr('stroke', function (d) {
		return d3.functor(conf.node_color)(tnode(d));
	    })
	    .attr('stroke-width', '2px');

	new_node.on("click", function (node) {
	    conf.on_click.call(this, tnode(node));
	});

	new_node.on("mouseover", function (node) {
	    conf.on_mouseover.call(this, tnode(node));
	});

	new_node.on("dblclick", function (node) {
	    conf.on_dbl_click.call(this, tnode(node));
	});

	new_node
	    .each (function (d) {
	    	conf.label.call(this, tnode(d));
	    });

	// Update plots an updated tree
	api.method ('update', function() {
	    var cluster = conf.layout.cluster;
	    var diagonal = conf.layout.diagonal();
	    var transform = conf.layout.transform_node;

	    var max_label_length = max_leaf_label_length(curr.tree);
	    conf.layout.max_leaf_label_width(max_label_length);

	    // Cluster size is the result of...
	    // total width of the vis - transform for the tree - max_leaf_label_width - horizontal transform of the label
	// TODO: Substitute 15 by the transform of the nodes (probably by selecting one node assuming all the nodes have the same transform
	    var n_leaves = curr.tree.get_all_leaves().length;
	    var cluster_size_params = {
		n_leaves : n_leaves,
		label_height : d3.functor(conf.label.height())(),
		label_padding : 15
	    };
	    conf.layout.adjust_cluster_size(cluster_size_params);

	    svg
		.transition()
		.duration(conf.duration)
		.ease(ease)
		.attr("height", conf.layout.height(cluster_size_params) + 30); // height is in the layout

	    vis
		.transition()
		.duration(conf.duration)
		.attr("transform",
		      "translate(" +
		      conf.layout.translate_vis()[0] +
		      "," +
		      conf.layout.translate_vis()[1] +
		      ")");
	    
	    curr.nodes = cluster.nodes(curr.data);
	    conf.layout.scale_branch_lengths(curr);
	    curr.links = cluster.links(curr.nodes);

        // NODES
	    var node = vis.selectAll("g.tnode")
		.data(curr.nodes, function(d) {return d._id});

	    // LINKS
	    var link = vis.selectAll("path.tree_link")
		.data(curr.links, function(d){return d.target._id});

	    var exit_link = link
		.exit()
		.remove();


	    // New links are inserted in the prev positions
	    link
		.enter()
		.append("path")
		.attr("class", "tree_link")
		.attr("id", function (d) {
		    return "tree_link_" + div_id + "_" + d.target._id;
		})
		// .attr("fill", "none")
		.attr("stroke", function (d) {
		    return d3.functor(conf.link_color)(tnode(d.source), tnode(d.target));
		})
		.attr("d", diagonal);

	    link
	    //  TODO: Here we will be moving links that have been already moved in the previous filter
	    //  if transitions are slow, this is a good place to optimize
	    	.transition()
		.ease(ease)
	    	.duration(conf.duration)
	    	.attr("d", diagonal);



	    // New nodes are created without radius
	    // The radius is created after the links
	    var new_node = node
		.enter()
		.append("g")
		.attr("class", function(n) {
		    if (n.children) {
			if (n.depth == 0) {
			    return "root tnode"
			} else {
			    return "inner tnode"
			}
		    } else {
			return "leaf tnode"
		    }
		})
		.attr("id", function (d) {
		    return "tnode_" + div_id + "_" + d._id;
		})
		.attr("transform", transform);
   
	    new_node
		.append('circle')
		.attr("r", 1e-6)
		.attr('stroke', function (d) {
		    return d3.functor(conf.node_color)(tnode(d));
		})
		.attr('stroke-width', '2px')
		.transition()
		.duration(conf.duration)
		.attr("r", function (d) {
		    return d3.functor(conf.node_circle_size)(tnode(d));
		});

	    new_node.on("click", function (node) {
		conf.on_click.call(this, tnode(node));
	    });

	    new_node.on("mouse_over", function (node) {
		conf.on_mouse_over(this, tnode(node));
	    });

	    new_node.on("dblclick", function (node) {
		conf.on_dbl_click.call(this, tnode(node));
	    });


	    // node color, size and labels are dynamic properties
	    node
		.select("circle")
		.transition()
		.attr('fill', function (d) {
		    return d3.functor(conf.node_color)(tnode(d));
		})
		.attr('r', function (d) {
		    return d3.functor(conf.node_circle_size)(tnode(d));
		})
		// node strokes are dynamic properties
		.attr('stroke', function (d) {
		    return d3.functor(conf.node_color)(tnode(d));
		});

	    // TODO: Shouldn't this be done only on new nodes? Old nodes should already have the labels
	    node
		.each (conf.label.remove)
		    .each (function (d) {
			conf.label.call(this, tnode(d));
		    });
	    
	    node
		.transition()
		.ease(ease)
		.duration(conf.duration)
		.attr("transform", transform);

	    // Exiting nodes are just removed
	    node
		.exit()
		.remove();
	});
    };

    // API
    //var api = tnt.utils.api (tree)
    //	.getset (conf)
    
    
  //  tree.duration         = 500;      // Duration of the transitions
  //  tree.label            = label.text();
  //  tree.layout           = layout.vertical();
  //  tree.on_click         = function () {};
  //  tree.on_dbl_click     = function () {};
  //  tree.on_mouseover    = function () {};
  //  tree.link_color       = 'steelblue';
  //  node_color       = 'steelblue';
  //  node_circle_size = 4.5;




    // TODO: Rewrite data using getset / finalizers & transforms
    tree.data = function (d) {
	if (!arguments.length) {
	    return base.data;
	}

	// The original data is stored as the base and curr data
	base.data = d;
	curr.data = d;

	// Set up a new tree based on the data
	var newtree = tnode(base.data);

	tree.root(newtree);
	return tree;
    };

    // TODO: Rewrite tree using getset / finalizers & transforms
    tree.root = function (t) {
    	if (!arguments.length) {
    	    return curr.tree;
    	}

	// The original tree is stored as the base, prev and curr tree
    	base.tree = t;
	curr.tree = base.tree;
//	prev.tree = base.tree;
    	return tree;
    };

    tree.subtree = function (curr_nodes) {
	var subtree = base.tree.subtree(curr_nodes);
	curr.data = subtree.data();
	curr.tree = subtree;

	return tree;
    };

    tree.focus_node = function (node) {
	// find 
	var found_node = tree.root().find_node_by_field(node.id(), '_id');
	focused_node = found_node
	tree.subtree(found_node.get_all_leaves());

	return tree;
    };

    tree.has_focus = function (node) {
	return ((focused_node !== undefined) && (focused_node.id() === node.id()));
    };

    tree.release_focus = function () {
	tree.data (base.data);
	focused_node = undefined;
	return tree;
    };


//    tree.tooltip = function () {
//	// var tooltip = tnt.tooltip().type("table");
//	var tooltip = tnt.tooltip.table();
//	var tree_tooltip = function (node) {
//	    node = node.data();
//	    var obj = {};
//	    obj.header = {
//		label : "Name",
//		value : node.name
//	    };
//	    obj.rows = [];
//	    obj.rows.push({
//		label : "_id",
//		value : node._id
//	    });
//	    obj.rows.push({
//		label : "Depth",
//		value : node.depth
//	    });
//	    obj.rows.push({
//		label : "Length",
//		value : node.length
//	    });
//	    obj.rows.push({
//		label : "N.Children",
//		value : node.children ? node.children.length : 0
//	    });
//	    tooltip.call(this, obj);
//	};
//
//	return tree_tooltip;
//    });

	// set default conf
	console.log(conf);
	for(var key in conf){
		console.log("key " +key);
		tree[key]= conf[key];
	}
	console.log(tree);
	console.log("--");


    return tree;
};

module.exports = tree;

},{"./label":4,"./layout":5,"./node":6}]},{},[1])